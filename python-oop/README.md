# Python OOP

## Functions

A function can take any number and type of input parameters and return any
number and type of output results.

```python
def do_nothing():
  pass
  
do_nothing();
```

### Positional Arguments

```python
def menu(wine, entree, dessert):
  return {'wine': wine, 'entree': entree, 'dessert': dessert}

menu('chardonnay', 'chicken', 'cake')
```

### Keyword Arguments

```python
def menu(wine, entree, dessert):
  return {'wine': wine, 'entree': entree, 'dessert': dessert}
  
menu(entree='beef', dessert='bagel', wine='bordeaux')
```

### Default Parameter Values

```python
def menu(wine, entree, dessert='pudding'):
  return {'wine': wine, 'entree': entree, 'dessert': dessert}
```

### Docstrings

```python
def echo(anything):
  'echo returns its input argument'
  return anything
```

```python
def print_if_true(thing, check):
  '''
  Prints the first argument if a second argument is true.
  The operation is:
  1. Check whether the *second* argument is true.
  2. If it is, print the *first* argument.
  '''
  if check:
    print(thing)
```

### First Class Functions

Functions in Python are just like functions in JavaScript. They can be assigned to variables, passed into other functions, and returned from functions themselves. 

```python
def say_something():
  print('This is something incredibly witty')
  
def execute_function(func):
  func()
  
execute_function(say_something)
```

### Inner Functions

```python
def outer(a, b):
  def inner(c, d):
    return c + d 
  return inner(a, b)

print(outer(1, 4))
# 5
```

### Closures 

An inner function can act as a closure. This is a function that is dynamically generated by another function and can both change and remember the values of variables that were created outside the function.

```python
def outer(a, b):
  def inner():
    return a + b 
  return inner

closure_example = outer(1, 4)

print(closure_example)
print(closure_example())
# <function inner at 0x7fb8006aa050>
# 5
```

## Classes

```python
class Person():
  pass
  
someone = Person()
```

### Constructors

```python
class Person():
  def __init__(self):
    pass
```

```python
class Person():
  def __init__(self, name):
    self.name = name
    
hunter = Person('Elmer Fudd')
```

__init__() is the special Python name for a method that initializes an individual object from its class definition. The self argument specifies that it refers to the individual object itself.

### Inheritance

> Inheriting from nothing creates an old-style class, which has different behaviour to new-style classes. As a general rule, there's no reason to favour old-style classes, so you should always inherit from `object`.

```python
class Car(object):
  pass

class Yugo(Car):
  pass
  
give_me_a_car = Car()
give_me_a_yugo = Yugo()
```

```python
class Car(object):
  def exclaim(self):
    print("I'm a Car!")

class Yugo(Car):
  pass
  
give_me_a_car = Car()
give_me_a_yugo = Yugo()
give_me_a_car.exclaim()
# I'm a Car!
give_me_a_yugo.exclaim()
# I'm a Car!
```

### Overriding Methods

```python
class Car(object):
  def exclaim(self):
    print("I'm a Car!")

class Yugo(Car):
  def exclaim(self):
    print("I'm a Yugo! Much like a Car, but more Yugo-ish.")
```

### Super

We can call the parent class with `super()`

```python
class Person(object):
  def __init__(self, name):
    self.name = name
    
class Hero(Person):
  def __init__(self, name, superpower):
    super(Hero, self).__init__(name)
    self.superpower = superpower
    
superman = Hero('Superman', 'Flying')

print(superman.superpower)
```

> With Python 3.x we no longer need to pass arguments into `super()` or pass `object` into the super class 

### Getters and Setters

```python
class Person(object):
  @property
  def name(self):
    print('inside the getter')
    return self.__name
  @name.setter
  def name(self, input_name):
    print('inside the setter')
    self.__name = input_name
```

```python
class Circle(object):
  def __init__(self, radius):
    self.radius = radius
  @property
  def diameter(self):
    return 2 * self.radius
    
c = Circle(5)
c.radius
# 5
c.diameter
# 10
```

### Class Methods

```python
class A(object):
  count = 0
  def __init__(self):
    A.count += 1
  def exclaim(self):
    print("I'm an A!")
  @classmethod
  def kids(cls):
    print("A has", cls.count, "little objects.")

easy_a = A()
breezy_a = A()
wheezy_a = A()
A.kids()
# A has 3 little objects.
```

### Packages and Modules

A module is a file containing Python definitions and statements. Modules allow us to write code in a reusable manner, any code within modules are loaded once and cached into `.pyc` files as bytecode. 

A Package in Python is just a directory with an `__init__.py` file in it. The file can be empty. Packages help us organize our code another level above just using modules. 



## Design Patterns

### Composition 

```python
class Bill(object):
  def __init__(self, description):
    self.description = description

class Tail(object):
  def __init__(self, length):
    self.length = length

class Duck(object):
  def __init__(self, bill, tail):
    self.bill = bill
    self.tail = tail
  def about(self):
    print('This duck has a', bill.description, 'bill and a', tail.length, 'tail')

tail = Tail('long')
bill = Bill('wide orange')
duck = Duck(bill, tail)
duck.about()
# This duck has a wide orange bill and a long tail
```

### Singletons

If you want only one of something, a module might be best. No matter how many
times a Python module is referenced in a program, only one copy is loaded. 

> Java and C++ programmers: if youâ€™re familiar with the book Design Patterns: Elements of Reusable Object-Oriented Software by Erich Gamma, you can use a Python module as a singleton.



## Resources

* Introducing Python - Modern Computing in Simple Packages
